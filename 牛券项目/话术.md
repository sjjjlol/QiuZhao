# 自我介绍

面试官好，我是一名新加坡南洋理工信号处理专业在读的研究生，本科毕业于华东师范大学通信工程专业。在校期间，我学习了java后端开发相关技术栈，包括java基础，jvm，java并发编程，开发框架如ssm，SpringBoot，关系型数据库mysql以及中间件redis和rocketmq。本科期间，我多次获得奖学金，专业课成绩在年级前百分之10，参加蓝桥杯、全国大学生数学竞赛等竞赛并获奖。



# 项目介绍

我最近做的一个项目是这个仿美团优惠券系统项目，这个项目模拟了美团的优惠券管理和发放机制，系统架构可以分为后管模块（实现了商家平台创建优惠券模板，创建优惠券分发任务等业务）、分发模块（具体实现了解析excel文件，向目标用户发放优惠券。），引擎层（采用缓存等手段，实现高并发场景下优惠券的查询、秒杀、预约通知等功能），结算层（实现用户使用优惠券购物结算的业务）。项目中我使用了一些设计模式对代码进行重构优化，比如用责任链模式实现参数校验，模板方法模式实现RocketMQ发送消息的功能。用redis和Spring AOP自定义了幂等注解。还有用布隆过滤器、双重判定锁等解决了缓存穿透、缓存击穿问题等。还用批处理优化了优惠券分发逻辑，解析分发5000条记录的时间从1分钟提升到了1s



## 你为什么选择 RocketMQ 作为消息队列，而不是 Kafka 或 RabbitMQ？

RocketMQ5.X支持任意时间的延时消息，通过设置最高能延迟1年，阿里开源的中间件，社区环境好，网上能找到很多相关博客进行学习。kafka我不太了解，

# 1.  责任链设计模式重构方法

目的：

**优惠券模板创建**时的参数验证，包括**参数非空**，**参数关系正确**（优惠券来源 0：店铺券 1：平台券，优惠类型 0：立减券 1：满减券 2：折扣券，有效期开始时间的合法性），**参数依赖关系**（调用商品中台验证商品是否存在）

**优惠券推送任务**时的参数验证，**参数非空**，**excel文件地址是否合法**，**参数依赖关系**（定时发送，延迟时间是否不为空）。

定义**责任链接口**，里面有**handle**方法（执行验证逻辑），**mark**方法（标志是同一个业务的验证责任链）。

**实现类**，实现接口，完成实际的handle方法验证，同时实现order接口，设置优先级

**责任链存储容器**，里面有一个**map**，key是**mark**，value是存储具体责任链的**容器**； **handle**方法，获取特定mark的**一组责任链**进行验证。

实现CommandLineRunner，ApplicationContextAware，程序启动后从Spring容器里面加载责任链，并按照优先级排序。

```java
@Override
    public void run(String... args) throws Exception {
        // 从 Spring IOC 容器中获取指定接口 Spring Bean 集合
        Map<String, MerchantAdminAbstractChainHandler> chainFilterMap = applicationContext.getBeansOfType(MerchantAdminAbstractChainHandler.class);
        chainFilterMap.forEach((beanName, bean) -> {
            // 判断 Mark 是否已经存在抽象责任链容器中，如果已经存在直接向集合新增；如果不存在，创建 Mark 和对应的集合
            List<MerchantAdminAbstractChainHandler> abstractChainHandlers = abstractChainHandlerContainer.getOrDefault(bean.mark(), new ArrayList<>());
            abstractChainHandlers.add(bean);
            abstractChainHandlerContainer.put(bean.mark(), abstractChainHandlers);
        });
        abstractChainHandlerContainer.forEach((mark, unsortedChainHandlers) -> {
            // 对每个 Mark 对应的责任链实现类集合进行排序，优先级小的在前
            unsortedChainHandlers.sort(Comparator.comparing(Ordered::getOrder));
        });
    }
```

## 创建优惠券模板其他逻辑

用Redis的**Hash结构**做缓存预热，因为优惠券模板存在库存，而我们后续会通过缓存扣减，如果使用字符串没办法做原子自减，而使用 Redis Hash 结构是可以针对某个字段进行自减的。

缓存的过期时间就用  expireAt（valid_end_time）

# 2.模板方法设计模式重构方法

定义一个抽象类

实现一个消息**发送通用方法**

- 将消息发送的逻辑（主要是根据**延迟时间**是否为空，判定是延迟消息还是立即消息）
- 结果**日志**（log.info("[生产者] {} - 发送结果：{}，消息ID：{}，消息Keys：{}）的打印进行了抽象。

定义抽象方法，实现对消息的包装。每个发送类去继承这个抽象类，重写**消息包装**方法，传进来的是只有关键字段的事件

- 包装方法实现发送实体的扩充，添加如name，topic，key。

举个例子

```
发送延时消息事件，优惠券活动到期修改优惠券模板状态
```

传入的参数，只有关键信息shopNumber，couponTemplateId，delayTime

```java
CouponTemplateDelayEvent templateDelayEvent = CouponTemplateDelayEvent.builder()
                .shopNumber(UserContext.getShopNumber())
                .couponTemplateId(couponTemplateDO.getId())
                .delayTime(couponTemplateDO.getValidEndTime().getTime())
                .build();
```

包装,加入eventName，keys（couponTemplateId提取），topic（前缀），delayTime

```java
 @Override
    protected BaseSendExtendDTO buildBaseSendExtendParam(CouponTemplateDelayEvent messageSendEvent) {
        return BaseSendExtendDTO.builder()
                .eventName("优惠券模板关闭定时执行")
                .keys(String.valueOf(messageSendEvent.getCouponTemplateId()))
                .topic(environment.resolvePlaceholders(MerchantAdminRocketMQConstant.TEMPLATE_TEMPLATE_DELAY_TOPIC_KEY))
                .delayTime(messageSendEvent.getDelayTime())
                .build();
    }
```

# 3. 幂等注解怎么实现的

自定义注解，用SpringAOP加强。通过lua脚本 SET KEY VAL NX GET PX。当redis中存在这个key的时候，不进行set，而是直接返回redis中的值。0就是消费中，这是抛出异常（消费中），让RocketMQ重试（**为了解决并发消费问题**），1就是消费完成，直接返回；当消息在redis中不存在的时候，返回的是null（说明第一次消费），先将val设置为0（消费中），执行业务逻辑，执行成功后，将val设置为1（消费完成），并设置过期时间，若执行业务失败抛出了一场，则删除key，并抛出异常重试。

key由 **业务前缀keyPrefix** + **消息的key**组成

```java
@NoMQDuplicateConsume(
            keyPrefix = "coupon_task_execute:idempotent:",
            key = "#messageWrapper.message.couponTaskId",
            keyTimeout = 120
    )
```



# 4.优惠券分发业务



(1)->（上一章的内容）后管服务创建分发任务表插入到数据库 -> 统计excel行数 -> 将行数插入优惠券分发任务表 ->发送定时消息或延时消息执行给分发引擎服务执行分发任务。

 (2) -> 校验消费者拿到消息并进行校验 -> 使用easyexal读取 -> Easyexcel监听类 记录执行点位 、执行缓存扣减，记录批量数据到缓存 -> 批量达到5000，发送消息给分发消费者 -> 分发消费者拿到消息(顺序执行) ->  批量保存到数据库 ->要是库存不足，批量记录到发放失败表 ->  更新分发任务表的完成时间



## 这个批处理和记录点位怎么实现的？

- 后管模块中，平台商家会创建优惠券分发任务，发送mq消息。

- 分发模块，**CouponTaskExecuteConsumer**进行 Excel 模板解析（ReadExcelDistributionListener），在消费者读取 Excel 执行记录时，如果发生宕机，消息队列在重试时需要重新执行整个任务，这显然会造成时间和资源的浪费。

- 为了优化这一点，我们在每次成功分发记录后，会将**进度行号**保存到缓存中，若宕机，下次执行的时候判断当前行号若小于等于**进度行号**，则直接跳过，直到达到上次的执行进度。

- lua脚本进行**库存扣减**以及记录**领券记录**，存到**set**中，key是batchUserSetKey是前缀+couponTaskId，value是ListUtil.of(couponTemplateKey, batchUserSetKey), JSON.toJSONString(userRowNumMap))
  - 若由于库存不足而分发失败，则写入到分发失败的数据库中。如果扣减失败，则将失败记录插入t_coupon_task_fail，记录失败原因：库存扣减失败。 并同步进度rowCount++到redis

- 如果不满足批量发送条件，数据应该暂存在 Redis 的 Set 缓存中，待满足批量条件时再从 Redis Set 中提取并执行批量保存。发送消息给CouponExecuteDistributionConsumer，将优惠券分发到用户账户

  - ```java
    CouponTemplateDistributionEvent couponTemplateDistributionEvent = CouponTemplateDistributionEvent.builder()
                    .userId(data.getUserId())
                    .mail(data.getMail())
                    .phone(data.getPhone())
                    .couponTaskId(couponTaskId)
                    .notifyType(couponTaskDO.getNotifyType())
                    .shopNumber(couponTaskDO.getShopNumber())
                    .couponTemplateId(couponTemplateDO.getId())
                    .couponTaskBatchId(couponTaskDO.getBatchId())
                    .couponTemplateConsumeRule(couponTemplateDO.getConsumeRule())
                    .batchUserSetSize(batchUserSetSize)
                    .distributionEndFlag(Boolean.FALSE)
                    .build();
            couponExecuteDistributionProducer.sendMessage(couponTemplateDistributionEvent);
    ```

- CouponExecuteDistributionConsumer，进行批量插入逻辑，这里用了**事务**。
- 为什么批量插入比单条插入快？

相同的 5000 条记录，v1 版本需要执行 1 分钟左右，v2 也就是当前版本仅需要 1 秒

每次都单条方式操作 Redis 和 MySQL，网络成本消耗巨大

### 存在的问题

如果 `batchSaveUserCouponList` 执行时数据库宕机，那么就会面临事务回滚问题，意味着我们需要将从 Redis 中获取的领券用户记录再保存到 Redis。

## easyExcel对比poi优势在哪？

#### **1. EasyExcel 相比 POI 的优势**

✅ **内存占用低**：

- POI 解析 Excel 需要 **把整个文件加载到内存**，容易OOM（尤其是大文件）。
- **EasyExcel 采用流式解析**，**基于 SAX 方式** 逐行读取，内存占用极低。

✅ **性能更高**：

- POI 处理 百万数据时，可能需要3G，甚至OOM。
- EasyExcel **仅占用200 MB**，速度更快，适用于大数据量 Excel 读写。

## 为什么批插入比单条插入快？

# 5.缓存穿透和缓存击穿的解决方案

查询优惠券是个高并发的操作，采用**布隆过滤器**+**缓存空值**解决缓存穿透问题，使用**双重判定锁**重建缓存解决了缓存击穿问题。
先判断布隆过滤器里有没有这个key，如果没有就直接返回，如果有（可能是误判），在看看有没有空值，有的话也返回，然后用双重判定锁（先尝试获取锁，进去以后再次判定是否在缓存中有，【为了让只有第一个拿到锁的线程去完成缓存重建】，然后查询数据库完成缓存重建，**如果发现数据库中没有，则加入空值**）

这里布隆过滤器我设置了（1000，0.001）,只占用 2kb内存

如果设置（1亿， 0.001）实际容量大概在 170M， 且布隆过滤器有上限40亿

解决方案：设置多个布隆过滤器，使得这些分片的布隆过滤器总容量能达到 300 亿。然后根据模板 ID 进行分片，确定要操作的布隆过滤器，从而在该分片上进行操作



上线的项目，如何清理布隆过滤器：

- 创建新布隆过滤器

- 先让一部分流量使用 `bloom_filter_v2`，观察数据正确性。确保新布隆过滤器加载完成后，替换所有流量。

- 删除旧 的布隆过滤器

```java
@RequiredArgsConstructor
public class ExcelDistributionListener extends AnalysisEventListener<CouponDistributionUserExcelBO> {

    private final CouponTemplateDO couponTemplateDO;

    private final RedisProxy redisProxy;

    private final CouponDistributionFailMapper couponDistributionFailMapper;

    private final CouponDistributionTaskDO taskDO;

    private final CouponDispenseProducer couponDispenseProducer;

    /**
     * 跳过标题，从第2行开始读excel
     */
    private long rowRecord = 2;

    /**
     * 分批次执行的大小
     */
    private static final int BATCH_SIZE = 200;

    /**
     * 分发失败记录的暂存区
     */
    private final List<CouponDistributionTaskFailDO> failRecordCacheList = new ArrayList<>(BATCH_SIZE);

    @Override
    public void invoke(CouponDistributionUserExcelBO excelData, AnalysisContext context) {
        String couponTemplateKey = StrUtil.join(":", "coupon-template", couponTemplateDO.getId());
        String processKey = StrUtil.join(":", "coupon-distribution-process", taskDO.getId());
        if (redisProxy.exist(couponTemplateKey)) {
            // 获取当前执行进度，优化因系统重启或宕机而重复执行分发
            String point = redisProxy.get(processKey, String.class);
            if (point != null && Integer.parseInt(point) >= rowRecord) {
                rowRecord++;
                return;
            }
            // 获取lua脚本对象并保存到单例容器，优化每次都需要重新创建脚本对象
            DefaultRedisScript<Long> luaScript = Singleton.get(AdminConstantPool.COUPON_DISTRIBUTION_TASK_LUA_SCRIPT, () -> {
                DefaultRedisScript<Long> script = new DefaultRedisScript<>();
                script.setScriptSource(new ResourceScriptSource(new ClassPathResource(AdminConstantPool.COUPON_DISTRIBUTION_TASK_LUA_SCRIPT)));
                script.setResultType(Long.class);
                return script;
            });
            String batchUserReceiveCouponKey = StrUtil.join(":", "user-coupon-collection", taskDO.getId());
            String userId = excelData.getUserId();
            Map<Object, Object> userRowNumMap = Collections.emptyMap();
            // 计算用户领券集合缓存分片键并判断当前用户是否已经领过该优惠券
            int mod = (Long.valueOf(userId).hashCode() & Integer.MAX_VALUE) % 5;
            String key = StrUtil.join(":", "user-gained-coupon", mod);
            String hashKey = StrUtil.join("-", userId, couponTemplateDO.getId());
            // 如果已领取过则将其保存为发券失败的记录
            if (redisProxy.getTemplateInstance().opsForHash().hasKey(key, hashKey)) {
                Map<Object, Object> contentMap = MapUtil.builder()
                        .put("userId", userId)
                        .put("cause", "用户已领取过该优惠券")
                        .build();
                CouponDistributionTaskFailDO taskFailDO = CouponDistributionTaskFailDO.builder()
                        .batchId(taskDO.getBatchId())
                        .content(JSONUtil.toJsonStr(contentMap))
                        .build();
                failRecordCacheList.add(taskFailDO);
            } else {
                userRowNumMap = Collections.singletonMap("userId", userId);
            }
            if (userRowNumMap.isEmpty()) {
                // 检查一下失败记录暂存区的大小，及时进行批处理，防止在极端情况下堆积大量失败记录导致ArrayList扩容
                if (failRecordCacheList.size() % BATCH_SIZE == 0) {
                    couponDistributionFailMapper.insert(failRecordCacheList);
                    failRecordCacheList.clear();
                }
                return;
            }
            // 扣减缓存中的优惠券库存以及新增记录到用户领券集合
            Long combineInt = redisProxy.getTemplateInstance().execute(luaScript,
                    Arrays.asList(couponTemplateKey, batchUserReceiveCouponKey),
                    JSONUtil.toJsonStr(userRowNumMap));
            assert combineInt != null;
            boolean hasInventory = BinarySplitUtil.extractFirstField(combineInt);
            if (!hasInventory) {
                failRecord(processKey, userId, "缓存中优惠券库存不足");
                return;
            }
            int setSize = BinarySplitUtil.extractSecondField(combineInt);
            if (setSize < BATCH_SIZE) {
                syncProcess(processKey);
                return;
            }
            // 通知另一个消费者执行分发，避免单条消息消费时间过长，这里取模可以保证每5000为一个批次的发消息，最后不足5000的交给后置逻辑来处理
            if (setSize % BATCH_SIZE == 0) {
                CouponDispenseMessage messageEvent = CouponDispenseMessage.builder()
                        .taskId(taskDO.getId())
                        .shopId(couponTemplateDO.getShopId())
                        .couponTemplateId(couponTemplateDO.getId())
                        .taskBatchId(taskDO.getBatchId())
                        .batchSetSize(BATCH_SIZE)
                        .endFlag(false)
                        .build();
                couponDispenseProducer.sendOrderlyMessage(messageEvent);
            }
            syncProcess(processKey);
        } else {
            failRecord(processKey, null,"优惠券缓存失效");
        }
    }

    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        CouponDispenseMessage messageEvent = CouponDispenseMessage.builder()
                .taskId(taskDO.getId())
                .shopId(couponTemplateDO.getShopId())
                .couponTemplateId(couponTemplateDO.getId())
                .taskBatchId(taskDO.getBatchId())
                .endFlag(true)
                .build();
        couponDispenseProducer.sendOrderlyMessage(messageEvent);
        if (!failRecordCacheList.isEmpty()) {
            couponDistributionFailMapper.insert(failRecordCacheList);
            failRecordCacheList.clear();
        }
    }

    /**
     * 保存分发失败的记录
     * @describe 批量执行最保险的方法应该是发mq，但正常执行几乎不可能会分发失败
     */
    private void failRecord(String processKey, String userId, String cause) {
        Map<Object, Object> contentMap = MapUtil.builder()
                .put("userId", userId)
                .put("cause", cause)
                .build();
        CouponDistributionTaskFailDO couponDistributionTaskFailDO = CouponDistributionTaskFailDO.builder()
                .batchId(taskDO.getBatchId())
                .content(JSONUtil.toJsonStr(contentMap))
                .build();
        failRecordCacheList.add(couponDistributionTaskFailDO);
        if (failRecordCacheList.size() % 100 == 0) {
            couponDistributionFailMapper.insert(failRecordCacheList);
            failRecordCacheList.clear();
        }
        syncProcess(processKey);
    }

    /**
     * 同步执行进度到缓存
     */
    private void syncProcess(String processKey) {
        redisProxy.set(processKey, String.valueOf(rowRecord));
        rowRecord++;
    }
```



```java
@Component
@RequiredArgsConstructor
@Slf4j
@RocketMQMessageListener(
        consumerGroup = AdminConstantPool.COUPON_DISPENSE_CG,
        topic = AdminConstantPool.COUPON_DISPENSE_TOPIC,
        consumeMode = ConsumeMode.ORDERLY
)
public class CouponDispenseConsumer implements RocketMQListener<CouponDispenseMessage> {

    private final RedisProxy redisProxy;

    private final CouponTemplateMapper couponTemplateMapper;

    private final UserCouponMapper userCouponMapper;

    private final CouponDistributionMapper couponDistributionMapper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void onMessage(CouponDispenseMessage messageEvent) {
        log.info("[消费者] 优惠券分发到用户，消息体：{}", JSONUtil.toJsonStr(messageEvent));
        // 非结束标识的batchSetSize已经存在，可以直接进行后续逻辑的处理
        if (!messageEvent.isEndFlag()) {
            handler(messageEvent);
            return;
        }
        // 获取当前用户领券集合的大小
        String batchUserReceiveCouponKey = StrUtil.join(":", "user-coupon-collection", messageEvent.getTaskId());
        Long userReceiveCouponSetSize = redisProxy.getTemplateInstance().opsForSet().size(batchUserReceiveCouponKey);
        // 用户领券集合缓存为空的情况：1.缓存失效 2.缓存中优惠券库存不足 3.最后这批用户都已领过该优惠券
        if (userReceiveCouponSetSize == null || userReceiveCouponSetSize == 0) {
            updateTaskStatus(messageEvent);
            return;
        }
        messageEvent.setBatchSetSize(userReceiveCouponSetSize.intValue());
        handler(messageEvent);
    }

    /**
     * 分发券的处理
     */
    @SneakyThrows
    private void handler(CouponDispenseMessage messageEvent) {
        Integer couponTemplateInventory = decrementInventory(messageEvent);
        if (couponTemplateInventory == 0) {
            RocketMQLogUtil.consumeFailure("优惠券分发到用户", messageEvent, "优惠券库存为空");
            return;
        }
        String batchUserReceiveCouponKey = StrUtil.join(":", "user-coupon-collection", messageEvent.getTaskId());
        // 扣减了多少张库存就从用户领券集合中pop出多少个待领券的用户信息
        List<String> userAndRowMap = redisProxy.getTemplateInstance().opsForSet().pop(batchUserReceiveCouponKey, couponTemplateInventory);
        if (userAndRowMap == null) {
            RocketMQLogUtil.consumeFailure("优惠券分发到用户", messageEvent, "缓存中用户领券集合为空");
            return;
        }
        // 初始化用户领券实体集合并指定大小，避免ArrayList扩容开销
        List<UserCouponDO> userCouponDOList = new ArrayList<>(couponTemplateInventory);
        userAndRowMap.forEach(item -> {
            JSONObject recordObject = JSONUtil.parseObj(item);
            UserCouponDO userCouponDO = UserCouponDO.builder()
                    .userId(recordObject.getLong("userId"))
                    .couponTemplateId(messageEvent.getCouponTemplateId())
                    .source(UserCouponSourceEnum.PLATFORM) // 只有平台才有权限获取用户隐私数据以及向用户派发券
                    .status(UserCouponStatusEnum.UNUSED)
                    .receiveCount(1) // 平台券限领1张
                    .build();
            userCouponDOList.add(userCouponDO);
        });
        // 批量新增用户领券记录
        batchSaveUserCouponList(messageEvent, userCouponDOList);
        StringBuilder stringBuilder = new StringBuilder();
        // 将用户领券记录保存到缓存中
        Map<Object, Object> valMap = MapUtil.builder()
                .put("count", 1) // 领券次数
                .put("date", DateUtil.date()) // 领券时间
                .build();
        userAndRowMap.forEach(each -> {
            Long userId = JSONUtil.parseObj(each).getLong("userId");
            // 取hashCode后按位与保证其值为正
            int mod = (userId.hashCode() & Integer.MAX_VALUE) % 5;
            String key = stringBuilder.append("user-gained-coupon").append(":").append(mod).toString();
            stringBuilder.setLength(0);
            String hashKey = stringBuilder.append(userId).append("-").append(messageEvent.getCouponTemplateId()).toString();
            redisProxy.hashSet(key, hashKey, JSONUtil.toJsonStr(valMap));
            stringBuilder.setLength(0);
        });
        // 确保全部分发完毕后更新推送任务的状态
        if (messageEvent.isEndFlag()) {
            updateTaskStatus(messageEvent);
        }
    }

    /**
     * 扣减优惠券库存
     * @return 扣减的库存数量
     */
    private Integer decrementInventory(CouponDispenseMessage messageEvent) {
        int res = couponTemplateMapper.decrementCouponTemplateInventory(messageEvent.getCouponTemplateId(),
                messageEvent.getShopId(),
                messageEvent.getBatchSetSize());
        // 库存不足导致扣减失败，需要重新获取可扣减的库存量，尽量让能发的券分发到用户
        if (res == 0) {
            LambdaQueryWrapper<CouponTemplateDO> queryWrapper = Wrappers.lambdaQuery(CouponTemplateDO.class)
                    .select(CouponTemplateDO::getInventory)
                    .eq(CouponTemplateDO::getShopId, messageEvent.getShopId())
                    .eq(CouponTemplateDO::getId, messageEvent.getCouponTemplateId());
            CouponTemplateDO couponTemplateDO = couponTemplateMapper.selectOne(queryWrapper);
            // 若库存已经为0则直接返回
            Integer inventory = couponTemplateDO.getInventory();
            if (inventory == 0)
                return 0;
            // 进行递归扣减
            messageEvent.setBatchSetSize(inventory);
            return decrementInventory(messageEvent);
        }
        return messageEvent.getBatchSetSize();
    }

    /**
     * 批量新增用户领券记录
     */
    private void batchSaveUserCouponList(CouponDispenseMessage messageEvent, List<UserCouponDO> userCouponDOList) {
        try {
            userCouponMapper.insert(userCouponDOList);
        } catch (Exception ex) {
            Throwable cause = ex.getCause();
            if (cause instanceof BatchExecutorException) {
                // 捕获唯一索引异常并记录日志
                RocketMQLogUtil.consumeFailure("优惠券分发到用户", messageEvent, ex);
            }
            throw new ServiceException(MerchantErrorCodeEnum.SERVICE_UPDATE_ERROR);
        }
    }

    /**
     * 更新推送任务状态
     */
    private void updateTaskStatus(CouponDispenseMessage messageEvent) {
        LambdaUpdateWrapper<CouponDistributionTaskDO> updateWrapper = Wrappers.lambdaUpdate(CouponDistributionTaskDO.class)
                .eq(CouponDistributionTaskDO::getId, messageEvent.getTaskId())
                .set(CouponDistributionTaskDO::getStatus, CouponDistributionStatusEnum.SUCCESS);
        if (couponDistributionMapper.update(updateWrapper) == 1) {
            // 清理excel读取进度缓存
            String processKey = StrUtil.join(":", "coupon-distribution-process", messageEvent.getTaskId());
            redisProxy.remove(processKey);
            RocketMQLogUtil.consumeSuccess("优惠券分发到用户", messageEvent);
            return;
        }
        RocketMQLogUtil.consumeFailure("优惠券分发到用户", messageEvent, "更新推送任务状态失败");
    }
```



# 6.秒杀逻辑

先验证要抢的券是否在缓存中，若不在的话会重建缓存，然后验证是否在有效时间内，再验证用户是否可以参与秒杀。开始秒杀逻辑，用lua脚本查询库存是否大于0，以及用户是否达到领取上限，然后增加用户领券次数，最后执行库存扣减。然后发mq消息，去进行mysql的库存扣减以及增加用户领券记录，这里在redis中也用zset进行存储，最后再发一个延迟消息，去执行到期过期逻辑。



# 7.数据库表设计

## 券模板表（分库分表）

```sql
CREATE TABLE `t_coupon_template`
(
    `id`               bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
    `name`             varchar(256) DEFAULT NULL COMMENT '优惠券名称',
    `shop_number`      bigint(20) DEFAULT NULL COMMENT '店铺编号',
    `source`           tinyint(1) DEFAULT NULL COMMENT '优惠券来源 0：店铺券 1：平台券',
    `target`           tinyint(1) DEFAULT NULL COMMENT '优惠对象 0：商品专属 1：全店通用',
    `goods`            varchar(64)  DEFAULT NULL COMMENT '优惠商品编码',
    `type`             tinyint(1) DEFAULT NULL COMMENT '优惠类型 0：立减券 1：满减券 2：折扣券',
    `valid_start_time` datetime     DEFAULT NULL COMMENT '有效期开始时间',
    `valid_end_time`   datetime     DEFAULT NULL COMMENT '有效期结束时间',
    `stock`            int(11) DEFAULT NULL COMMENT '库存',
    `receive_rule`     json         DEFAULT NULL COMMENT '领取规则',
    `consume_rule`     json         DEFAULT NULL COMMENT '消耗规则',
    `status`           tinyint(1) DEFAULT NULL COMMENT '优惠券状态 0：生效中 1：已结束',
    `create_time`      datetime     DEFAULT NULL COMMENT '创建时间',
    `update_time`      datetime     DEFAULT NULL COMMENT '修改时间',
    `del_flag`         tinyint(1) DEFAULT NULL COMMENT '删除标识 0：未删除 1：已删除',
    PRIMARY KEY (`id`),
    KEY                `idx_shop_number` (`shop_number`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1810967816300515330 DEFAULT CHARSET=utf8mb4 COMMENT='优惠券模板表';
```

单台 MySQL Server 的写瓶颈大概在 4000-5000/TPS，如果我们的场景业务每秒 TPS 在 1 万，那么就需要至少分两个库



### shop_number字段

用作分片键

### source字段

平台券：平台创建，成本由平台和商家一起承担

商家券：商家自己创建，成本由商家承担

### target，goods字段

goods暂时用的是varchar存储，用分号分割

若商品过多，可能有会有查询效率低的问题，改进：

可以建立 `t_coupon_template_goods` 关联表，并用  (`goods_code`, `coupon_template_id`)做联合索引

```sql
CREATE TABLE `t_coupon_template_goods`
(
    `id`               bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
    `coupon_template_id` bigint(20) NOT NULL COMMENT '优惠券模板ID',
    `goods_code`       varchar(64) NOT NULL COMMENT '商品编码',
    `create_time`      datetime DEFAULT NULL COMMENT '创建时间',
    `update_time`      datetime DEFAULT NULL COMMENT '修改时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uniq_coupon_goods` (`coupon_template_id`, `goods_code`),
    KEY `idx_goods_code` (`goods_code`) USING BTREE,
    CONSTRAINT `fk_coupon_template` FOREIGN KEY (`coupon_template_id`) REFERENCES `t_coupon_template` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='优惠券模板适用商品表';

```

### type，stock，status 字段

type：优惠类型 0：立减券 1：满减券 2：折扣券

stock：券库存

### valid_start_time，valid_end_time 字段

有效时间



## 用户领券记录表

```sql
CREATE TABLE `t_user_coupon` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `coupon_template_id` bigint(20) DEFAULT NULL COMMENT '优惠券模板ID',
  `receive_time` datetime DEFAULT NULL COMMENT '领取时间',
  `receive_count` int(3) DEFAULT NULL COMMENT '领取次数',
  `valid_start_time` datetime DEFAULT NULL COMMENT '有效期开始时间',
  `valid_end_time` datetime DEFAULT NULL COMMENT '有效期结束时间',
  `use_time` datetime DEFAULT NULL COMMENT '使用时间',
  `source` tinyint(1) DEFAULT NULL COMMENT '券来源 0：领券中心 1：平台发放 2：店铺领取',
  `status` tinyint(1) DEFAULT NULL COMMENT '状态 0：未使用 1：锁定 2：已使用 3：已过期 4：已撤回',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  `del_flag` tinyint(1) DEFAULT NULL COMMENT '删除标识 0：未删除 1：已删除',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_user_id_coupon_template_receive_count` (`user_id`,`coupon_template_id`,`receive_count`) USING BTREE,
  KEY `idx_user_id` (`user_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1815640588360376337 DEFAULT CHARSET=utf8mb4 COMMENT='用户优惠券表';
```



# 8.防止重复提交

Redisson 分布式锁的 底层`key-value` 结构

**Key（锁的名称）**：

- `lock:{lockName}`

**Value（锁的持有者信息）**：

- `UUID:ThreadId`（唯一标识客户端和线程的组合）



## key的设置

```java
String lockKey = String.format("no-duplicate-submit:path:%s:currentUserId:%s:md5:%s", getServletPath(), getCurrentUserId(), calcArgsMD5(joinPoint));

```

**固定前缀**no-duplicate-submit

**当前请求的 URL 路径** getServletPath

**获取当前用户** ID  currentUserId

计算请求参数（切点）的 MD5 calcArgsMD5(joinPoint)



