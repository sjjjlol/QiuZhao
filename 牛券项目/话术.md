# 自我介绍

面试官好，我是一名新加坡南洋理工信号处理专业在读的研究生，本科毕业于华东师范大学通信工程专业。在校期间，我学习了java后端开发相关技术栈，包括java基础，jvm，java并发编程，开发框架如ssm，SpringBoot，关系型数据库mysql以及中间件redis和rocketmq。本科期间，我多次获得奖学金，专业课成绩在年级前百分之10，参加蓝桥杯、全国大学生数学竞赛等竞赛并获奖。



# 项目介绍

我最近做的一个项目是这个仿美团优惠券系统项目，这个项目模拟了美团的优惠券管理和发放机制，系统架构可以分为后管模块（实现了商家平台创建优惠券模板，创建优惠券分发任务等业务）、分发模块（具体实现了解析excel文件，向目标用户发放优惠券。），引擎层（采用缓存等手段，实现高并发场景下优惠券的查询、秒杀、预约通知等功能），结算层（实现用户使用优惠券购物结算的业务）。项目中我使用了一些设计模式对代码进行重构优化，比如用责任链模式实现参数校验，模板方法模式实现RocketMQ发送消息的功能。用redis和Spring AOP自定义了幂等注解。还有用布隆过滤器、双重判定锁等解决了缓存穿透、缓存击穿问题等。还用批处理优化了优惠券分发逻辑，解析分发5000条记录的时间从1分钟提升到了1s



## 你为什么选择 RocketMQ 作为消息队列，而不是 Kafka 或 RabbitMQ？

RocketMQ5.X支持任意时间的延时消息，通过设置最高能延迟1年，阿里开源的中间件，社区环境好，网上能找到很多相关博客进行学习。kafka我不太了解，

# 1.  责任链设计模式重构方法

目的：

**优惠券模板创建**时的参数验证，包括**参数非空**，**参数关系正确**（优惠券来源 0：店铺券 1：平台券，优惠类型 0：立减券 1：满减券 2：折扣券，有效期开始时间的合法性），**参数依赖关系**（调用商品中台验证商品是否存在）

**优惠券推送任务**时的参数验证，**参数非空**，**excel文件地址是否合法**，**参数依赖关系**（定时发送，延迟时间是否不为空）。

定义**责任链接口**，里面有**handle**方法（执行验证逻辑），**mark**方法（标志是同一个业务的验证责任链）。

**实现类**，实现接口，完成实际的handle方法验证，同时实现order接口，设置优先级

**责任链存储容器**，里面有一个**map**，key是**mark**，value是存储具体责任链的**容器**； **handle**方法，获取特定mark的**一组责任链**进行验证。

实现CommandLineRunner，ApplicationContextAware，程序启动后从Spring容器里面加载责任链，并按照优先级排序。

```java
@Override
    public void run(String... args) throws Exception {
        // 从 Spring IOC 容器中获取指定接口 Spring Bean 集合
        Map<String, MerchantAdminAbstractChainHandler> chainFilterMap = applicationContext.getBeansOfType(MerchantAdminAbstractChainHandler.class);
        chainFilterMap.forEach((beanName, bean) -> {
            // 判断 Mark 是否已经存在抽象责任链容器中，如果已经存在直接向集合新增；如果不存在，创建 Mark 和对应的集合
            List<MerchantAdminAbstractChainHandler> abstractChainHandlers = abstractChainHandlerContainer.getOrDefault(bean.mark(), new ArrayList<>());
            abstractChainHandlers.add(bean);
            abstractChainHandlerContainer.put(bean.mark(), abstractChainHandlers);
        });
        abstractChainHandlerContainer.forEach((mark, unsortedChainHandlers) -> {
            // 对每个 Mark 对应的责任链实现类集合进行排序，优先级小的在前
            unsortedChainHandlers.sort(Comparator.comparing(Ordered::getOrder));
        });
    }
```

## 创建优惠券模板其他逻辑

用Redis的**Hash结构**做缓存预热，因为优惠券模板存在库存，而我们后续会通过缓存扣减，如果使用字符串没办法做原子自减，而使用 Redis Hash 结构是可以针对某个字段进行自减的。

缓存的过期时间就用  expireAt（valid_end_time）

# 2.模板方法设计模式重构方法

定义一个抽象类

实现一个消息**发送通用方法**

- 将消息发送的逻辑（主要是根据**延迟时间**是否为空，判定是延迟消息还是立即消息）
- 结果**日志**（log.info("[生产者] {} - 发送结果：{}，消息ID：{}，消息Keys：{}）的打印进行了抽象。

定义抽象方法，实现对消息的包装。每个发送类去继承这个抽象类，重写**消息包装**方法，传进来的是只有关键字段的事件

- 包装方法实现发送实体的扩充，添加如name，topic，key。

举个例子

```
发送延时消息事件，优惠券活动到期修改优惠券模板状态
```

传入的参数，只有关键信息shopNumber，couponTemplateId，delayTime

```java
CouponTemplateDelayEvent templateDelayEvent = CouponTemplateDelayEvent.builder()
                .shopNumber(UserContext.getShopNumber())
                .couponTemplateId(couponTemplateDO.getId())
                .delayTime(couponTemplateDO.getValidEndTime().getTime())
                .build();
```

包装,加入eventName，keys（couponTemplateId提取），topic（前缀），delayTime

```java
 @Override
    protected BaseSendExtendDTO buildBaseSendExtendParam(CouponTemplateDelayEvent messageSendEvent) {
        return BaseSendExtendDTO.builder()
                .eventName("优惠券模板关闭定时执行")
                .keys(String.valueOf(messageSendEvent.getCouponTemplateId()))
                .topic(environment.resolvePlaceholders(MerchantAdminRocketMQConstant.TEMPLATE_TEMPLATE_DELAY_TOPIC_KEY))
                .delayTime(messageSendEvent.getDelayTime())
                .build();
    }
```

# 3. 幂等注解怎么实现的

自定义注解，用SpringAOP加强。通过lua脚本 SET KEY VAL NX GET PX。当redis中存在这个key的时候，不进行set，而是直接返回redis中的值。0就是消费中，这是抛出异常（消费中），让RocketMQ重试（**为了解决并发消费问题**），1就是消费完成，直接返回；当消息在redis中不存在的时候，返回的是null（说明第一次消费），先将val设置为0（消费中），执行业务逻辑，执行成功后，将val设置为1（消费完成），并设置过期时间，若执行业务失败抛出了一场，则删除key，并抛出异常重试。

key由 **业务前缀keyPrefix** + **消息的key**组成

```java
@NoMQDuplicateConsume(
            keyPrefix = "coupon_task_execute:idempotent:",
            key = "#messageWrapper.message.couponTaskId",
            keyTimeout = 120
    )
```



# 4.优惠券分发业务

## 这个批处理和记录点位怎么实现的？

- 后管模块中，平台商家会创建优惠券分发任务，发送mq消息。

- 分发模块，**CouponTaskExecuteConsumer**进行 Excel 模板解析（ReadExcelDistributionListener），在消费者读取 Excel 执行记录时，如果发生宕机，消息队列在重试时需要重新执行整个任务，这显然会造成时间和资源的浪费。

- 为了优化这一点，我们在每次成功分发记录后，会将**进度行号**保存到缓存中，若宕机，下次执行的时候判断当前行号若小于等于**进度行号**，则直接跳过，直到达到上次的执行进度。

- lua脚本进行**库存扣减**以及记录**领券记录**，存到**set**中，key是batchUserSetKey是前缀+couponTaskId，value是ListUtil.of(couponTemplateKey, batchUserSetKey), JSON.toJSONString(userRowNumMap))
  - 若由于库存不足而分发失败，则写入到分发失败的数据库中。如果扣减失败，则将失败记录插入t_coupon_task_fail，记录失败原因：库存扣减失败。 并同步进度rowCount++到redis

- 如果不满足批量发送条件，数据应该暂存在 Redis 的 Set 缓存中，待满足批量条件时再从 Redis Set 中提取并执行批量保存。发送消息给CouponExecuteDistributionConsumer，将优惠券分发到用户账户

  - ```java
    CouponTemplateDistributionEvent couponTemplateDistributionEvent = CouponTemplateDistributionEvent.builder()
                    .userId(data.getUserId())
                    .mail(data.getMail())
                    .phone(data.getPhone())
                    .couponTaskId(couponTaskId)
                    .notifyType(couponTaskDO.getNotifyType())
                    .shopNumber(couponTaskDO.getShopNumber())
                    .couponTemplateId(couponTemplateDO.getId())
                    .couponTaskBatchId(couponTaskDO.getBatchId())
                    .couponTemplateConsumeRule(couponTemplateDO.getConsumeRule())
                    .batchUserSetSize(batchUserSetSize)
                    .distributionEndFlag(Boolean.FALSE)
                    .build();
            couponExecuteDistributionProducer.sendMessage(couponTemplateDistributionEvent);
    ```

- CouponExecuteDistributionConsumer，进行批量插入逻辑，这里用了**事务**。
- 为什么批量插入比单条插入快？

相同的 5000 条记录，v1 版本需要执行 1 分钟左右，v2 也就是当前版本仅需要 1 秒

每次都单条方式操作 Redis 和 MySQL，网络成本消耗巨大

### 存在的问题

如果 `batchSaveUserCouponList` 执行时数据库宕机，那么就会面临事务回滚问题，意味着我们需要将从 Redis 中获取的领券用户记录再保存到 Redis。

## easyExcel对比poi优势在哪？

#### **1. EasyExcel 相比 POI 的优势**

✅ **内存占用低**：

- POI 解析 Excel 需要 **把整个文件加载到内存**，容易OOM（尤其是大文件）。
- **EasyExcel 采用流式解析**，**基于 SAX 方式** 逐行读取，内存占用极低。

✅ **性能更高**：

- POI 处理 百万数据时，可能需要3G，甚至OOM。
- EasyExcel **仅占用200 MB**，速度更快，适用于大数据量 Excel 读写。

## 为什么批插入比单条插入快？

# 5.缓存穿透和缓存击穿的解决方案

查询优惠券是个高并发的操作，采用**布隆过滤器**+**缓存空值**解决缓存穿透问题，使用**双重判定锁**重建缓存解决了缓存击穿问题。
先判断布隆过滤器里有没有这个key，如果没有就直接返回，如果有（可能是误判），在看看有没有空值，有的话也返回，然后用双重判定锁（先尝试获取锁，进去以后再次判定是否在缓存中有，【为了让只有第一个拿到锁的线程去完成缓存重建】，然后查询数据库完成缓存重建，**如果发现数据库中没有，则加入空值**）

这里布隆过滤器我设置了（1000，0.001）,只占用 2kb内存

如果设置（1亿， 0.001）实际容量大概在 170M， 且布隆过滤器有上限40亿

解决方案：设置多个布隆过滤器，使得这些分片的布隆过滤器总容量能达到 300 亿。然后根据模板 ID 进行分片，确定要操作的布隆过滤器，从而在该分片上进行操作



上线的项目，如何清理布隆过滤器：

- 创建新布隆过滤器

- 先让一部分流量使用 `bloom_filter_v2`，观察数据正确性。确保新布隆过滤器加载完成后，替换所有流量。

- 删除旧 的布隆过滤器

# 6.秒杀逻辑

先验证要抢的券是否在缓存中，若不在的话会重建缓存，然后验证是否在有效时间内，再验证用户是否可以参与秒杀。开始秒杀逻辑，用lua脚本查询库存是否大于0，以及用户是否达到领取上限，然后增加用户领券次数，最后执行库存扣减。然后发mq消息，去进行mysql的库存扣减以及增加用户领券记录，这里在redis中也用zset进行存储，最后再发一个延迟消息，去执行到期过期逻辑。



# 7.数据库表设计

## 券模板表（分库分表）

```sql
CREATE TABLE `t_coupon_template`
(
    `id`               bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
    `name`             varchar(256) DEFAULT NULL COMMENT '优惠券名称',
    `shop_number`      bigint(20) DEFAULT NULL COMMENT '店铺编号',
    `source`           tinyint(1) DEFAULT NULL COMMENT '优惠券来源 0：店铺券 1：平台券',
    `target`           tinyint(1) DEFAULT NULL COMMENT '优惠对象 0：商品专属 1：全店通用',
    `goods`            varchar(64)  DEFAULT NULL COMMENT '优惠商品编码',
    `type`             tinyint(1) DEFAULT NULL COMMENT '优惠类型 0：立减券 1：满减券 2：折扣券',
    `valid_start_time` datetime     DEFAULT NULL COMMENT '有效期开始时间',
    `valid_end_time`   datetime     DEFAULT NULL COMMENT '有效期结束时间',
    `stock`            int(11) DEFAULT NULL COMMENT '库存',
    `receive_rule`     json         DEFAULT NULL COMMENT '领取规则',
    `consume_rule`     json         DEFAULT NULL COMMENT '消耗规则',
    `status`           tinyint(1) DEFAULT NULL COMMENT '优惠券状态 0：生效中 1：已结束',
    `create_time`      datetime     DEFAULT NULL COMMENT '创建时间',
    `update_time`      datetime     DEFAULT NULL COMMENT '修改时间',
    `del_flag`         tinyint(1) DEFAULT NULL COMMENT '删除标识 0：未删除 1：已删除',
    PRIMARY KEY (`id`),
    KEY                `idx_shop_number` (`shop_number`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1810967816300515330 DEFAULT CHARSET=utf8mb4 COMMENT='优惠券模板表';
```

单台 MySQL Server 的写瓶颈大概在 4000-5000/TPS，如果我们的场景业务每秒 TPS 在 1 万，那么就需要至少分两个库



### shop_number字段

用作分片键

### source字段

平台券：平台创建，成本由平台和商家一起承担

商家券：商家自己创建，成本由商家承担

### target，goods字段

goods暂时用的是varchar存储，用分号分割

若商品过多，可能有会有查询效率低的问题，改进：

可以建立 `t_coupon_template_goods` 关联表，并用  (`goods_code`, `coupon_template_id`)做联合索引

```sql
CREATE TABLE `t_coupon_template_goods`
(
    `id`               bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
    `coupon_template_id` bigint(20) NOT NULL COMMENT '优惠券模板ID',
    `goods_code`       varchar(64) NOT NULL COMMENT '商品编码',
    `create_time`      datetime DEFAULT NULL COMMENT '创建时间',
    `update_time`      datetime DEFAULT NULL COMMENT '修改时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uniq_coupon_goods` (`coupon_template_id`, `goods_code`),
    KEY `idx_goods_code` (`goods_code`) USING BTREE,
    CONSTRAINT `fk_coupon_template` FOREIGN KEY (`coupon_template_id`) REFERENCES `t_coupon_template` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='优惠券模板适用商品表';

```

### type，stock，status 字段

type：优惠类型 0：立减券 1：满减券 2：折扣券

stock：券库存

### valid_start_time，valid_end_time 字段

有效时间



## 用户领券记录表

```sql
CREATE TABLE `t_user_coupon` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户ID',
  `coupon_template_id` bigint(20) DEFAULT NULL COMMENT '优惠券模板ID',
  `receive_time` datetime DEFAULT NULL COMMENT '领取时间',
  `receive_count` int(3) DEFAULT NULL COMMENT '领取次数',
  `valid_start_time` datetime DEFAULT NULL COMMENT '有效期开始时间',
  `valid_end_time` datetime DEFAULT NULL COMMENT '有效期结束时间',
  `use_time` datetime DEFAULT NULL COMMENT '使用时间',
  `source` tinyint(1) DEFAULT NULL COMMENT '券来源 0：领券中心 1：平台发放 2：店铺领取',
  `status` tinyint(1) DEFAULT NULL COMMENT '状态 0：未使用 1：锁定 2：已使用 3：已过期 4：已撤回',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  `del_flag` tinyint(1) DEFAULT NULL COMMENT '删除标识 0：未删除 1：已删除',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_user_id_coupon_template_receive_count` (`user_id`,`coupon_template_id`,`receive_count`) USING BTREE,
  KEY `idx_user_id` (`user_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1815640588360376337 DEFAULT CHARSET=utf8mb4 COMMENT='用户优惠券表';
```



# 8.防止重复提交

Redisson 分布式锁的 底层`key-value` 结构

**Key（锁的名称）**：

- `lock:{lockName}`

**Value（锁的持有者信息）**：

- `UUID:ThreadId`（唯一标识客户端和线程的组合）



## key的设置

```java
String lockKey = String.format("no-duplicate-submit:path:%s:currentUserId:%s:md5:%s", getServletPath(), getCurrentUserId(), calcArgsMD5(joinPoint));

```

**固定前缀**no-duplicate-submit

**当前请求的 URL 路径** getServletPath

**获取当前用户** ID  currentUserId

计算请求参数（切点）的 MD5 calcArgsMD5(joinPoint)



