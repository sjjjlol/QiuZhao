# 冒泡

通过相邻元素的比较和交换，每次将最大（或最小）的元素逐步“冒泡”到最后（或最前）

```java
    // 冒泡排序算法
    private static void bubbleSort(int[] arr, int n) {
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换 arr[j] 和 arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

```



# 选择

每次从 **未排序部分** 找到 **最小元素**，然后交换到 **当前排序位置**，使用 `minIndex` 记录最小值索引，避免不必要的交换操作

```java
    // 选择排序算法
    private static void selectionSort(int[] arr, int n) {
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i; // 假设当前索引是最小值索引

            // 找到从 i 到 n-1 之间的最小值索引
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }

            // 如果 minIndex 发生了变化，则进行交换
            if (minIndex != i) {
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }

```



# 插入

将待排序元素逐个插入到已排序序列的合适位置，形成有序序列

```java
    // 经典插入排序
    private static void insertionSort(int[] arr, int n) {
        for (int i = 1; i < n; i++) {
            int key = arr[i]; // 取出当前元素
            int j = i - 1;
            
            // 向左寻找合适的插入位置
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j]; // 向右移动元素
                j--;
            }
            
            // 插入元素
            arr[j + 1] = key;
        }
    }

```



# 归并

将数组不断分割为更小的子数组，然后将子数组进行合并，合并过程中进行排序

![img](https://developer.qcloudimg.com/http-save/yehe-9735680/d044df1aa39b97f2ff9a2ae57a682038.png)

```java
import java.util.Arrays;

class Solution {
    public void mergeSort(int[] nums) {
        if (nums == null || nums.length <= 1) return;
        mergeSortHelper(nums, 0, nums.length - 1);
    }

    private void mergeSortHelper(int[] nums, int left, int right) {
        if (left >= right) return; // 递归终止条件

        int mid = (left + right)/ 2; // 计算中点
        mergeSortHelper(nums, left, mid);    // 递归排序左半部分
        mergeSortHelper(nums, mid + 1, right); // 递归排序右半部分
      
        // 归并已排序的左右部分
      	int[] temp = new int[right - left + 1]; // 临时数组存放合并后的结果
        int i = left, j = mid + 1, k = 0;

        while (i <= mid && j <= right) { // 比较左右两部分，合并到 temp
            if (nums[i] < nums[j]) {
                temp[k++] = nums[i++];
            } else {
                temp[k++] = nums[j++];
            }
        }

        while (i <= mid) temp[k++] = nums[i++]; // 处理剩余的左半部分
        while (j <= right) temp[k++] = nums[j++]; // 处理剩余的右半部分

        // 将排序后的结果拷贝回原数组
        System.arraycopy(temp, 0, nums, left, temp.length);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {4, 2, 1, 3, 6, 5, 8, 7};
        solution.mergeSort(nums);
        System.out.println(Arrays.toString(nums)); // 输出排序后的数组
    }
}

```



# 快速

通过选择一个基准元素，将数组划分为两个子数组，使得左子数组的元素都小于（或等于）基准元素，右子数组的元素都大于（或等于）基准元素，然后对子数组进行递归排序。

[快排视频教程](https://www.bilibili.com/video/BV1Um421J7UC/?spm_id_from=333.337.search-card.all.click&vd_source=55c287a81883465b30c11b1feb8b72c3)

```java
 // 经典快速排序（使用快慢指针进行 partition）
    private static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int pivotIndex = partition(arr, left, right);
            quickSort(arr, left, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, right);
        }
    }

    // 分区函数（使用快慢指针，最右侧元素作为 pivot）
    private static int partition(int[] arr, int left, int right) {
        int pivot = arr[right]; // 选取最右侧元素为基准
        int slow = left; // 慢指针，指向下一个小于 pivot 的存放位置

        for (int fast = left; fast < right; fast++) {
            if (arr[fast] < pivot) {
                swap(arr, slow, fast);
                slow++; // 慢指针向右移动
            }
        }

        // 最后将 pivot 放到正确位置（slow 指向的索引）
        swap(arr, slow, right);
        return slow;
    }

    // 交换数组中的两个元素
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

```





# 排序复杂度总结

![image-20240725233717608](https://cdn.xiaolincoding.com//picgo/image-20240725233717608.png)