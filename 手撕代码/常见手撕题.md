# 多线程题

## 三个线程轮流打印从1~100

```java
public class PrintNumbersSync_wait {
    static final int MAX = 10;
    static int count = 1;
    static final Object lock = new Object();
    static int turn = 1; // 控制轮到哪个线程

    public static void main(String[] args) {
        Runnable printTask = () -> {
            int threadNum = Integer.parseInt(Thread.currentThread().getName().substring(1)); // 获取线程编号

            while (true) {
                synchronized (lock) {
                    // 不该当前线程打印，则 wait
                    while (count <= MAX && turn != threadNum) {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }

                    // 退出条件必须放在 synchronized 代码块内部
                    if (count > MAX) {
                        lock.notifyAll(); // 唤醒其他线程，确保它们能够正常退出
                        break;
                    }

                    System.out.println("线程 " + Thread.currentThread().getName() + " -> " + count++);
                    turn = turn % 3 + 1; // 轮到下一个线程执行
                    try {
                        Thread.sleep(500); // 让线程休眠，模拟执行间隔
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    lock.notifyAll(); // 唤醒其他线程
                }

            }
        };

        new Thread(printTask, "T1").start();
        new Thread(printTask, "T2").start();
        new Thread(printTask, "T3").start();
    }
}

```



```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class PrintNumbersReentrantLock_condition {
    private static final int MAX_NUM = 10;
    private static int count = 1;
    private static final ReentrantLock lock = new ReentrantLock();
    private static final Condition[] conditions = new Condition[3];
    private static int turn = 0; // 用于标识当前该哪个线程执行

    public static void main(String[] args) {
        for (int i = 0; i < 3; i++) {
            conditions[i] = lock.newCondition();
        }

        Runnable printTask = () -> {
            int threadId = Integer.parseInt(Thread.currentThread().getName().substring(1)); // 获取线程编号
            while (true) {
                lock.lock();
                try {
                    while (count <= MAX_NUM && turn != threadId) {
                        conditions[threadId].await();
                    }

                    if (count > MAX_NUM) {
                        for (Condition condition : conditions) {
                            condition.signalAll(); // 唤醒所有线程，确保线程安全退出
                        }
                        break;
                    }

                    System.out.println("线程 " + Thread.currentThread().getName() + " -> " + count++);
                    turn = (turn + 1) % 3; // 轮到下一个线程执行
                    conditions[turn].signal(); // 唤醒下一个线程

                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        };

        new Thread(printTask, "T1").start();
        new Thread(printTask, "T2").start();
        new Thread(printTask, "T3").start();
    }
}

```

### **为什么 `ReentrantLock` 更优**

- `synchronized` 的 `wait/notifyAll` 方式需要 `notifyAll` 唤醒所有等待线程，可能会导致不必要的上下文切换，而 `Condition` 可以精准唤醒下一个线程，提高效率。
- `ReentrantLock` 提供了更好的可控性，能灵活地管理多个 `Condition`，相比 `synchronized` 更容易扩展。

## 统计词频

磁盘上有10个文件，每个文件格式：
hello world
nice to meet you
写一个Java程序，并发读文件，统计词频，最终返回Map res，在规定时间内没读完统计多少就返回多少

```java
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class WordFrequencyCounter {
    private static final int THREAD_COUNT = 5; // 线程池大小
    private static final int TIME_LIMIT = 10; // 最大执行时间（秒）

    public static Map<String, Integer> countWordFrequency(List<File> files) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        ConcurrentHashMap<String, Integer> wordCountMap = new ConcurrentHashMap<>();
        List<Future<?>> futures = new ArrayList<>();

        long startTime = System.currentTimeMillis();

        for (File file : files) {
            Future<?> future = executor.submit(() -> {
                try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        for (String word : line.split("\\s+")) { // 按空格分词
                            if (!word.isEmpty()) {
                                wordCountMap.merge(word, 1, Integer::sum);
                            }
                        }

                        // 超时检测
                        if (System.currentTimeMillis() - startTime > TIME_LIMIT * 1000) {
                            return;
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
            futures.add(future);
        }

        // 等待所有任务完成或超时
        for (Future<?> future : futures) {
            try {
                future.get(TIME_LIMIT, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                System.out.println("超时，返回当前统计结果...");
                break;
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }

        executor.shutdownNow(); // 终止所有线程
        return wordCountMap;
    }

    public static void main(String[] args) {
        List<File> files = new ArrayList<>();
        for (int i = 1; i <= 10; i++) {
            files.add(new File("file" + i + ".txt"));
        }

        try {
            Map<String, Integer> result = countWordFrequency(files);
            result.entrySet().stream()
                    .sorted((a, b) -> b.getValue().compareTo(a.getValue())) // 按词频排序
                    .forEach(entry -> System.out.println(entry.getKey() + ": " + entry.getValue()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```



# 手写LRU

```java
import java.util.HashMap;
import java.util.Map;

public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
  	//size维护当前缓存中结点数量
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部（最近使用）
      	// moveToHead实现：先删除当前节点，再加入到头结点
        moveToHead(node);//删除+放入头结点
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```



## 手写LFU

```java
import java.util.HashMap;
import java.util.LinkedHashSet;

class LFUCache {
    class Node {
        int key, value, freq;
        public Node(int _key, int _value) {
            key = _key;
            value = _value;
            freq = 1;
        }
    }

    private final int capacity;
    private int minFreq = 0;
    private final HashMap<Integer, Node> cache = new HashMap<>();
    private final HashMap<Integer, LinkedHashSet<Integer>> freqToKeys = new HashMap<>();

    public LFUCache(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) return -1;
        updateFreq(key);
        return cache.get(key).value;
    }

    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            node.value = value;
            updateFreq(key);
        } else {
            if (cache.size() >= capacity) {
                removeLFU();
            }
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            freqToKeys.computeIfAbsent(1, k -> new LinkedHashSet<>()).add(key);
            minFreq = 1; // 新插入的 key 访问频率一定是 1
        }
    }

    private void updateFreq(int key) {
        Node node = cache.get(key);
        int freq = node.freq;
        freqToKeys.get(freq).remove(key);
        if (freqToKeys.get(freq).isEmpty()) {
            freqToKeys.remove(freq);
            if (minFreq == freq) minFreq++; // 更新最小频率
        }
        node.freq++;
        freqToKeys.computeIfAbsent(node.freq, k -> new LinkedHashSet<>()).add(key);
    }

    private void removeLFU() {
        int removedKey = freqToKeys.get(minFreq).iterator().next();
        freqToKeys.get(minFreq).remove(removedKey);
        if (freqToKeys.get(minFreq).isEmpty()) freqToKeys.remove(minFreq);
        keyToNode.remove(removedKey);
    }
}

```



# 单例模式

## 双重检查锁

```java
public class SingletonDCL {
    private static volatile SingletonDCL instance; // volatile 防止指令重排

    private SingletonDCL() {} // 私有构造方法，防止外部实例化

    public static SingletonDCL getInstance() {
        if (instance == null) { // 第一次检查，避免不必要的同步
            synchronized (SingletonDCL.class) { // 线程同步
                if (instance == null) { // 第二次检查，确保只有一个实例
                    instance = new SingletonDCL();
                }
            }
        }
        return instance;
    }
}

```



## 静态内部类

```java
public class SingletonStatic {
    private SingletonStatic() {} // 私有构造方法

    private static class SingletonHolder {
        private static final SingletonStatic INSTANCE = new SingletonStatic();
    }

    public static SingletonStatic getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

```



# 手写ThreadLocal

```java
import java.util.WeakHashMap;

public class MyThreadLocal<T> {
    private final WeakHashMap<Thread, T> threadLocalMap = new WeakHashMap<>();

    // 获取当前线程的值
    public T get() {
        synchronized (threadLocalMap) {
            return threadLocalMap.get(Thread.currentThread());
        }
    }

    // 设置当前线程的值
    public void set(T value) {
        synchronized (threadLocalMap) {
            threadLocalMap.put(Thread.currentThread(), value);
        }
    }

    // 移除当前线程的变量，防止内存泄漏
    public void remove() {
        synchronized (threadLocalMap) {
            threadLocalMap.remove(Thread.currentThread());
        }
    }

    public static void main(String[] args) {
        MyThreadLocal<Integer> myThreadLocal = new MyThreadLocal<>();

        Runnable task = () -> {
            myThreadLocal.set((int) (Math.random() * 100));
            System.out.println(Thread.currentThread().getName() + " -> " + myThreadLocal.get());
        };

        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");

        t1.start();
        t2.start();
    }
}

```



# 手写HashMap

```java
import java.util.Objects;

public class MyHashMap<K, V> {
    private static class Node<K, V> {
        final K key;
        V value;
        Node<K, V> next;

        public Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private static final int DEFAULT_CAPACITY = 16; // 默认容量
    private static final float LOAD_FACTOR = 0.75f; // 负载因子
    private Node<K, V>[] table;
    private int size;

    public MyHashMap() {
        this.table = new Node[DEFAULT_CAPACITY];
    }

    // 计算哈希索引
    private int hash(K key) {
        return (key == null) ? 0 : (key.hashCode() & 0x7FFFFFFF) % table.length;
    }

    // put() 方法
    public void put(K key, V value) {
        int index = hash(key);
        Node<K, V> newNode = new Node<>(key, value);

        if (table[index] == null) {
            table[index] = newNode; // 直接存储
        } else {
            // 遍历链表，检查是否已有 key，若有则更新 value
            Node<K, V> current = table[index];
            while (true) {
                if (Objects.equals(current.key, key)) {
                    current.value = value; // 覆盖已有值
                    return;
                }
                if (current.next == null) break;
                current = current.next;
            }
            current.next = newNode; // 插入链表尾部
        }

        size++;
        if (size > table.length * LOAD_FACTOR) {
            resize(); // 负载因子超过阈值，进行扩容
        }
    }

    // get() 方法
    public V get(K key) {
        int index = hash(key);
        Node<K, V> current = table[index];

        while (current != null) {
            if (Objects.equals(current.key, key)) {
                return current.value; // 找到 key 返回 value
            }
            current = current.next;
        }

        return null; // key 不存在
    }

    // 扩容方法
    private void resize() {
        Node<K, V>[] oldTable = table;
        table = new Node[oldTable.length * 2]; // 扩容为原来的 2 倍
        size = 0;

        for (Node<K, V> head : oldTable) {
            while (head != null) {
                put(head.key, head.value); // 重新哈希后插入新表
                head = head.next;
            }
        }
    }

    public static void main(String[] args) {
        MyHashMap<String, Integer> map = new MyHashMap<>();
        map.put("apple", 1);
        map.put("banana", 2);
        map.put("cherry", 3);
        map.put("apple", 10); // 更新 key="apple" 的值

        System.out.println(map.get("apple")); // 输出: 10s
        System.out.println(map.get("banana")); // 输出: 2
        System.out.println(map.get("cherry")); // 输出: 3
        System.out.println(map.get("grape")); // 输出: null
    }
}

```

# 实现一个死锁

```java
public class deadLock {
    static final Object resource1 = new Object();
    static final Object resource2 = new Object();
    public static void main(String[] args) {
        Runnable task1 = () -> {
            synchronized (resource1){
                System.out.println("线程1获得了资源1");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("线程1等待中。。。");
                synchronized (resource2) {
                    System.out.println("线程1获得了资源2");
                }
            }
        };
        Runnable task2 = () -> {
            synchronized (resource2){
                System.out.println("线程2获得了资源2");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("线程2等待中。。。");
                synchronized (resource1) {
                    System.out.println("线程2获得了资源1");
                }
            }
        };
        new Thread(task1).start();
        new Thread(task2).start();
    }
}

```

